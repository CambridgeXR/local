<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f19" />
  <title>XR Viewer</title>
  <link rel="manifest" href="./manifest.json" />
  <style>
    :root { --bg:#0b0f19; --fg:#e5e7eb; --muted:#9aa3b2; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    #app { position:fixed; inset:0; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }

    /* Minimal overlay UI */
    .ui { position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; }
    .ui-inner { pointer-events:auto; display:flex; flex-direction:column; gap:.75rem; align-items:center; }
    button { appearance:none; border:0; padding:.9rem 1.1rem; border-radius:1rem; background:#121a2b; color:var(--fg); font-weight:600; letter-spacing:.2px; box-shadow:0 6px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05); width:200px; }
    button:active { transform: translateY(1px); }
    .title { font-style: italic; color: var(--muted); font-size:.9rem; margin-top:.25rem; }

    /* Show/Hide with fade */
    .hidden { opacity:0; transform: translateY(8px); pointer-events:none; }
    .visible { opacity:1; transform: translateY(0); }
    .fade { transition: opacity .25s ease, transform .25s ease; }

    /* Tap target to toggle controls */
    #tapzone { position:fixed; inset:0; background:transparent; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="tapzone" aria-label="toggle controls"></div>

  <!-- Minimal UI -->
  <div class="ui">
    <div id="ui" class="ui-inner fade visible">
      <button id="selectBtn">Select simulation</button>
      <button id="vrBtn" disabled>Enter VR</button>
      <button id="recenterBtn">Recenter</button>
      <div class="title">Brought to you by Cambridge XR</div>
    </div>
  </div>

  <!-- Hidden input for local video selection -->
  <input id="file" type="file" accept="video/*" style="display:none" />

  <!-- three.js core -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/DeviceOrientationControls.js"></script>

  <script>
  (function(){
    const app = document.getElementById('app');

    // Power helpers: wake lock + robust fullscreen
    let wakeLock = null;
    async function requestWakeLock(){
      try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
    }
    document.addEventListener('visibilitychange', async () => {
      if (wakeLock !== null && document.visibilityState === 'visible') {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){}
      }
    });
    async function goFullscreen(){
      const el = document.documentElement;
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      } catch(e){}
    }

    // Create video element
    const video = document.createElement('video');
    video.setAttribute('playsinline', '');
    video.loop = true;
    video.preload = 'metadata';
    video.crossOrigin = 'anonymous';

    // Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // allow WebXR if available
    app.appendChild(renderer.domElement);

    // Create sphere for 360 video (inside-out)
    let sphere, material, texture;
    function buildSphere() {
      const geometry = new THREE.SphereGeometry(500, 64, 64);
      geometry.scale(-1, 1, 1); // invert to view from inside
      texture = new THREE.VideoTexture(video);
      texture.colorSpace = THREE.SRGBColorSpace;
      material = new THREE.MeshBasicMaterial({ map: texture });
      sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);
    }
    buildSphere();

    // Device orientation controls (rotation only)
    const controls = new THREE.DeviceOrientationControls(camera, true);
    controls.connect();

    // ---- State ----
    let yawOffset = 0;        // applied in mono/stereo modes
    let mode = 'mono';        // 'mono' | 'stereo' | 'webxr'
    // smoothing for reduced jitter
    const SMOOTH_ALPHA = 0.12; // 0..1 per frame
    const smoothedQuat = new THREE.Quaternion();
    smoothedQuat.copy(camera.quaternion);

    // Recenter by zeroing yaw offset (mono/stereo) or rotating world (XR)
    function recenter() {
      if (mode === 'webxr') {
        const xrCam = renderer.xr.getCamera();
        const euler = new THREE.Euler().setFromQuaternion(xrCam.quaternion, 'YXZ');
        sphere.rotation.y = -euler.y; // rotate world to face forward
      } else {
        const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
        yawOffset = euler.y; // subtract in render loop
      }
    }

    // ---- Rendering ----
    function renderMono(){
      controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);
      renderer.setScissorTest(false);
      renderer.render(scene, camera);
    }

    function renderStereo(){
      controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);

      const w = renderer.domElement.width;
      const h = renderer.domElement.height;

      renderer.setScissorTest(true);
      // Left eye
      renderer.setViewport(0, 0, w/2, h);
      renderer.setScissor(0, 0, w/2, h);
      renderer.render(scene, camera);
      // Right eye
      renderer.setViewport(w/2, 0, w/2, h);
      renderer.setScissor(w/2, 0, w/2, h);
      renderer.render(scene, camera);
      renderer.setScissorTest(false);
    }

    // WebXR loop (phone + supported browser)
    const xrLoop = () => { renderer.render(scene, camera); };

    function animate(){
      if (mode === 'webxr') return; // XR uses setAnimationLoop
      requestAnimationFrame(animate);
      if (mode === 'stereo') renderStereo(); else renderMono();
    }
    animate();

    // Resize
    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // UI logic: auto-hide after tap and toggle on any screen tap
    const ui = document.getElementById('ui');
    const tapzone = document.getElementById('tapzone');
    let uiTimer = null;
    const showUI = () => {
      ui.classList.remove('hidden');
      ui.classList.add('visible');
      clearTimeout(uiTimer);
      uiTimer = setTimeout(() => hideUI(), 2500);
    };
    const hideUI = () => {
      ui.classList.remove('visible');
      ui.classList.add('hidden');
    };
    tapzone.addEventListener('click', () => {
      const isHidden = ui.classList.contains('hidden');
      if (isHidden) showUI(); else hideUI();
      if (video.src && video.paused) video.play().catch(()=>{});
    });
    uiTimer = setTimeout(() => hideUI(), 3000);

    // Buttons
    const selectBtn = document.getElementById('selectBtn');
    const vrBtn = document.getElementById('vrBtn');
    const recenterBtn = document.getElementById('recenterBtn');
    const fileInput = document.getElementById('file');

    selectBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      startVideo(url);
    });

    function startVideo(src){
      video.src = src;
      video.muted = false;
      video.play().then(() => {
        vrBtn.disabled = false;
      }).catch(() => {
        // Autoplay with sound may be blocked; try muted
        video.muted = true;
        video.play().then(() => { vrBtn.disabled = false; }).catch(()=>{});
      });
    }

    async function enterCardboard(){
      await goFullscreen();
      try { await screen.orientation.lock('landscape'); } catch {}
      await requestWakeLock();
      mode = 'stereo';
      showUI();
    }

    async function enterWebXR(){
      try {
        const supported = await (navigator.xr && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported('immersive-vr') : Promise.resolve(false));
        if (!supported) return false;
        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','bounded-floor'] });
        renderer.xr.setReferenceSpaceType('local');
        renderer.setAnimationLoop(xrLoop);
        await renderer.xr.setSession(session);
        mode = 'webxr';
        return true;
      } catch (e) {
        console.warn('WebXR failed, falling back to stereo', e);
        return false;
      }
    }

    async function enterVR(){
      // Prefer WebXR; fallback to stereo fullscreen
      const ok = await enterWebXR();
      if (!ok) await enterCardboard();
    }

    // Wire buttons
    document.getElementById('vrBtn').addEventListener('click', enterVR);
    recenterBtn.addEventListener('click', recenter);

    // Optional: drag & drop
    document.addEventListener('dragover', e => { e.preventDefault(); });
    document.addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && file.type.startsWith('video/')) startVideo(URL.createObjectURL(file));
    });

    // Prevent pinch-zoom
    window.addEventListener('touchmove', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive:false });
  })();
  </script>
</body>
</html>
