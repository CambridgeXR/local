<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>360 VR Player (Cambridge XR)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#000000"/>

  <!-- (Optional) PWA Manifest; keep if you already have the files -->
  <link rel="manifest" href="manifest.json">

  <!-- App icons (keep your existing files/paths) -->
  <link rel="icon" sizes="192x192" href="icons/icon-192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
  <link rel="apple-touch-icon" sizes="512x512" href="icons/icon-512.png">

  <style>
    html, body {
      margin:0; padding:0; height:100%; background:#000; color:#fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overscroll-behavior: contain; touch-action: manipulation;
    }
    canvas { display:block; width:100vw; height:100vh; }

    #ui { position:fixed; inset:0; display:grid; place-items:center; pointer-events:none;
      opacity:1; transition:opacity .4s ease; }
    #ui.fade { opacity:0; }
    #ui.hidden { display:none; }

    .panel { pointer-events:auto; display:grid; gap:12px; width:min(92vw,520px); text-align:center; }
    .btn { appearance:none; border:none; outline:none; padding:14px 16px; border-radius:12px;
      font-weight:600; font-size:1.05rem; background:#1a73e8; color:#fff; box-shadow:0 6px 18px rgba(26,115,232,.35);
      cursor:pointer; transition:transform .06s ease, filter .2s ease, opacity .2s ease; width:100%; }
    .btn.secondary { background:#2b2b2b; box-shadow:0 6px 18px rgba(0,0,0,.35); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }
    input[type=file]{ display:none; }

    .brand { opacity:.7; font-size:.75rem; margin-top:4px; font-style:italic; transition:opacity .4s ease; }
    .brand.hidden { opacity:0; }

    #toast { position:fixed; bottom:14px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,.65); color:#fff; font-size:.95rem; padding:10px 12px; border-radius:10px;
      opacity:0; transition:opacity .25s ease; pointer-events:none; }
    #toast.show { opacity:1; }

    @media (prefers-reduced-motion: reduce) { #ui, .brand, #toast { transition:none; } }
  </style>
</head>
<body>

  <!-- Rendering surface -->
  <canvas id="glcanvas" aria-label="360 VR Canvas"></canvas>

  <!-- Hidden <video> used as the texture -->
  <video id="video360" playsinline webkit-playsinline preload="metadata" loop crossorigin="anonymous" style="display:none"></video>

  <!-- Minimal floating UI -->
  <div id="ui" aria-live="polite">
    <div class="panel">
      <button id="selectBtn" class="btn secondary" type="button">Select simulation</button>
      <input id="fileInput" type="file" accept="video/*" />
      <button id="cardboardBtn" class="btn" type="button" disabled>Enter Cardboard</button>
      <button id="recenterBtn" class="btn secondary" type="button" disabled>Recenter (tap)</button>
      <div id="brandText" class="brand">Brought to you by Cambridge XR</div>
    </div>
  </div>

  <div id="toast" role="status" aria-live="polite"></div>

  <script>
  (() => {
    // ======== UI helpers ========
    const HIDE_DELAY = 5000;
    const ui = document.getElementById('ui');
    const toast = document.getElementById('toast');
    const brand = document.getElementById('brandText');
    let hideUITimer = null;

    function showToast(msg, ms = 1800) {
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.classList.remove('show'), ms);
    }
    function scheduleUIHide() {
      clearTimeout(hideUITimer);
      hideUITimer = setTimeout(() => { ui.classList.add('fade'); }, HIDE_DELAY);
    }
    function showUI() {
      clearTimeout(hideUITimer);
      ui.classList.remove('hidden');
      void ui.offsetWidth;
      ui.classList.remove('fade');
      scheduleUIHide();
    }
    addEventListener('pointerdown', showUI, {passive:true});

    // ======== Video / file handling ========
    const fileInput = document.getElementById('fileInput');
    const selectBtn = document.getElementById('selectBtn');
    const cardboardBtn = document.getElementById('cardboardBtn');
    const recenterBtn = document.getElementById('recenterBtn');
    const video = document.getElementById('video360');
    let objectURL = null;

    selectBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      try {
        if (objectURL) URL.revokeObjectURL(objectURL);
        objectURL = URL.createObjectURL(file);
        video.src = objectURL;
        video.loop = true;
        video.playsInline = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        await ensureVideoPlays();
        cardboardBtn.disabled = false;
        recenterBtn.disabled = false;
        showToast('Simulation loaded.');
        showUI();
      } catch (err) {
        console.error(err);
        showToast('Could not load video.');
      }
    });

    async function ensureVideoPlays() {
      try {
        // Start muted for autoplay on Android; user can raise volume with HW keys
        video.muted = true;
        await video.play();
      } catch (e) { /* a second tap may be needed on some devices */ }
    }

    // ======== Wake Lock & orientation ========
    let wakeLock = null;
    async function requestWakeLock() {
      try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); }
      catch (e) {}
    }
    document.addEventListener('visibilitychange', async () => {
      if (wakeLock !== null && document.visibilityState === 'visible') {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch (e) {}
      }
    });

    async function lockLandscape() {
      try {
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('landscape');
        }
      } catch(e) {}
    }

    async function goFullscreen() {
      try {
        const el = document.documentElement;
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      } catch (e) {}
    }

    // ======== DeviceOrientation (quaternion-based, robust for Android) ========
    // Implements mapping equivalent to three.js DeviceOrientationControls:
    //   euler.set(beta, alpha, -gamma, 'YXZ');
    //   q = fromEuler(euler) * q1 * qScreen(-orientZ)
    // where q1 = rotation of -PI/2 around X (camera looks out the back),
    // and screen orientation compensates portrait/landscape.

    // Small quaternion helper set
    function quatFromEulerYXZ(beta, alpha, minusGamma) {
      // beta (X), alpha (Y), -gamma (Z), order YXZ
      const x = beta, y = alpha, z = minusGamma;
      const c1 = Math.cos(y/2), c2 = Math.cos(x/2), c3 = Math.cos(z/2);
      const s1 = Math.sin(y/2), s2 = Math.sin(x/2), s3 = Math.sin(z/2);
      // Y * X * Z
      const q = new Float32Array(4);
      q[0] = s2*c1*c3 + c2*s1*s3; // x
      q[1] = c2*s1*c3 - s2*c1*s3; // y
      q[2] = c2*c1*s3 + s2*s1*c3; // z
      q[3] = c2*c1*c3 - s2*s1*s3; // w
      return q;
    }
    function quatMultiply(a, b) {
      return new Float32Array([
        a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
        a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
        a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
        a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2]
      ]);
    }
    function quatConjugate(q) { return new Float32Array([-q[0], -q[1], -q[2], q[3]]); }
    function quatSlerp(a, b, t) {
      let cosom = a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3];
      let bx = b[0], by = b[1], bz = b[2], bw = b[3];
      if (cosom < 0) { cosom = -cosom; bx = -bx; by = -by; bz = -bz; bw = -bw; }
      let scale0, scale1;
      if (1 - cosom > 1e-6) {
        const omega = Math.acos(cosom);
        const sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        // nearly identical; lerp
        scale0 = 1 - t; scale1 = t;
      }
      return new Float32Array([
        scale0*a[0] + scale1*bx,
        scale0*a[1] + scale1*by,
        scale0*a[2] + scale1*bz,
        scale0*a[3] + scale1*bw
      ]);
    }
    function quatToMat4(q) {
      const x=q[0], y=q[1], z=q[2], w=q[3];
      const x2=x+x, y2=y+y, z2=z+z;
      const xx=x*x2, xy=x*y2, xz=x*z2;
      const yy=y*y2, yz=y*z2, zz=z*z2;
      const wx=w*x2, wy=w*y2, wz=w*z2;
      // rotation matrix (column-major)
      return new Float32Array([
        1-(yy+zz), xy+wz,    xz-wy,    0,
        xy-wz,     1-(xx+zz),yz+wx,    0,
        xz+wy,     yz-wx,    1-(xx+yy),0,
        0,         0,        0,        1
      ]);
    }
    function mat4Invert(out, a) {
      const m=a, b=new Float32Array(16);
      b[0]=m[5]*m[10]*m[15]-m[5]*m[11]*m[14]-m[9]*m[6]*m[15]+m[9]*m[7]*m[14]+m[13]*m[6]*m[11]-m[13]*m[7]*m[10];
      b[4]=-m[4]*m[10]*m[15]+m[4]*m[11]*m[14]+m[8]*m[6]*m[15]-m[8]*m[7]*m[14]-m[12]*m[6]*m[11]+m[12]*m[7]*m[10];
      b[8]=m[4]*m[9]*m[15]-m[4]*m[11]*m[13]-m[8]*m[5]*m[15]+m[8]*m[7]*m[13]+m[12]*m[5]*m[11]-m[12]*m[7]*m[9];
      b[12]=-m[4]*m[9]*m[14]+m[4]*m[10]*m[13]+m[8]*m[5]*m[14]-m[8]*m[6]*m[13]-m[12]*m[5]*m[10]+m[12]*m[6]*m[9];
      b[1]=-m[1]*m[10]*m[15]+m[1]*m[11]*m[14]+m[9]*m[2]*m[15]-m[9]*m[3]*m[14]-m[13]*m[2]*m[11]+m[13]*m[3]*m[10];
      b[5]=m[0]*m[10]*m[15]-m[0]*m[11]*m[14]-m[8]*m[2]*m[15]+m[8]*m[3]*m[14]+m[12]*m[2]*m[11]-m[12]*m[3]*m[10];
      b[9]=-m[0]*m[9]*m[15]+m[0]*m[11]*m[13]-m[8]*m[1]*m[15]-m[8]*m[3]*m[13]-m[12]*m[1]*m[11]+m[12]*m[3]*m[9];
      b[13]=m[0]*m[9]*m[14]-m[0]*m[10]*m[13]-m[8]*m[1]*m[14]+m[8]*m[2]*m[13]+m[12]*m[1]*m[10]-m[12]*m[2]*m[9];
      b[2]=m[1]*m[6]*m[15]-m[1]*m[7]*m[14]-m[5]*m[2]*m[15]+m[5]*m[3]*m[14]+m[13]*m[2]*m[7]-m[13]*m[3]*m[6];
      b[6]=-m[0]*m[6]*m[15]+m[0]*m[7]*m[14]+m[4]*m[2]*m[15]-m[4]*m[3]*m[14]-m[12]*m[2]*m[7]+m[12]*m[3]*m[6];
      b[10]=m[0]*m[5]*m[15]-m[0]*m[7]*m[13]-m[4]*m[1]*m[15]+m[4]*m[3]*m[13]+m[12]*m[1]*m[7]-m[12]*m[3]*m[5];
      b[14]=-m[0]*m[5]*m[14]+m[0]*m[6]*m[13]+m[4]*m[1]*m[14]-m[4]*m[2]*m[13]-m[12]*m[1]*m[6]+m[12]*m[2]*m[5];
      b[3]=-m[1]*m[6]*m[11]+m[1]*m[7]*m[10]+m[5]*m[2]*m[11]-m[5]*m[3]*m[10]-m[9]*m[2]*m[7]+m[9]*m[3]*m[6];
      b[7]=m[0]*m[6]*m[11]-m[0]*m[7]*m[10]-m[4]*m[2]*m[11]+m[4]*m[3]*m[10]+m[8]*m[2]*m[7]-m[8]*m[3]*m[6];
      b[11]=-m[0]*m[5]*m[11]+m[0]*m[7]*m[9]+m[4]*m[1]*m[11]-m[4]*m[3]*m[9]-m[8]*m[1]*m[7]+m[8]*m[3]*m[5];
      b[15]=m[0]*b[0]+m[1]*b[4]+m[2]*b[8]+m[3]*b[12];
      let det = m[0]*b[0] + m[1]*b[4] + m[2]*b[8] + m[3]*b[12];
      if (!det) { out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return out; }
      det = 1.0/det; for (let i=0;i<16;i++) out[i]=b[i]*det; return out;
    }

    // Constant rotations
    const q1_minusHalfPiX = new Float32Array([ -Math.SQRT1_2, 0, 0, Math.SQRT1_2 ]); // -PI/2 about X
    function qFromAxisAngleZ(angle) {
      const s = Math.sin(angle/2), c = Math.cos(angle/2);
      return new Float32Array([0,0,s,c]); // axis Z
    }

    // Orientation state
    let targetHeadQ = new Float32Array([0,0,0,1]); // device-derived
    let smoothedHeadQ = new Float32Array([0,0,0,1]); // filtered
    let recenterQ = new Float32Array([0,0,0,1]); // yaw-only recenter offset
    let havePermission = false;

    function getScreenOrientationRad() {
      const ang = (screen.orientation && typeof screen.orientation.angle === 'number')
        ? screen.orientation.angle
        : (window.orientation || 0);
      return (ang || 0) * Math.PI / 180;
    }

    async function requestOrientationPermission() {
      try {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          const resp = await DeviceOrientationEvent.requestPermission();
          havePermission = (resp === 'granted');
        } else {
          // Chrome Android typically doesn't require requestPermission()
          havePermission = true;
        }
      } catch (e) { havePermission = false; }
      return havePermission;
    }

    function updateTargetQuaternionFromDevice(alpha, beta, gamma) {
      // Convert to radians
      const a = (alpha || 0) * Math.PI/180;     // Z (compass)
      const b = (beta  || 0) * Math.PI/180;     // X' (front/back tilt)
      const g = (gamma || 0) * Math.PI/180;     // Y'' (left/right tilt)
      // Device to world: euler(beta, alpha, -gamma, 'YXZ')
      let q = quatFromEulerYXZ(b, a, -g);
      // Camera looks out the back of the device, not the top
      q = quatMultiply(q, q1_minusHalfPiX);
      // Compensate for screen orientation (portrait/landscape)
      const orient = getScreenOrientationRad();
      const qScreen = qFromAxisAngleZ(-orient);
      q = quatMultiply(q, qScreen);
      // Apply recenter (yaw-only offset)
      q = quatMultiply(recenterQ, q);
      targetHeadQ = q;
    }

    // Recenter: capture current yaw and zero it
    function extractYawFromQuat(q) {
      // yaw around Y in world after our mapping; compute from matrix
      const m = quatToMat4(q);
      // From rotation matrix, yaw = atan2(m[8], m[0]) in our construction? Use standard yaw from Z-forward camera.
      // We want rotation around world up (Y). Using heading = atan2(m[2], m[10]) depends on convention.
      // Safer: project forward vector and compute angle in XZ plane.
      const fx = m[8];  const fz = m[10]; // third column is forward (camera -Z); our matrix maps object->world
      const yaw = Math.atan2(fx, fz);
      return yaw;
    }
    function quatFromYaw(yaw) {
      const s = Math.sin(yaw/2), c = Math.cos(yaw/2);
      return new Float32Array([0, s, 0, c]); // rotate about Y
    }
    function recenterNow() {
      // Set recenterQ to inverse of current yaw
      const yaw = extractYawFromQuat(targetHeadQ);
      const qYawInv = quatConjugate(quatFromYaw(yaw));
      recenterQ = qYawInv;
      showToast('View recentered');
    }

    // Device orientation events (use both if available)
    function onDeviceOrientation(e) {
      if (e.alpha == null || e.beta == null || e.gamma == null) return;
      updateTargetQuaternionFromDevice(e.alpha, e.beta, e.gamma);
    }
    window.addEventListener('deviceorientation', onDeviceOrientation, true);
    // Some devices fire 'deviceorientationabsolute'; listen too
    window.addEventListener('deviceorientationabsolute', onDeviceOrientation, true);

    // Button for recenter
    recenterBtn.addEventListener('click', recenterNow);

    // Also allow quick tap on canvas to recenter when in Cardboard
    document.getElementById('glcanvas').addEventListener('click', () => {
      if (cardboard) recenterNow();
    });

    // ======== WebGL setup ========
    const canvas = document.getElementById('glcanvas');
    let gl = canvas.getContext('webgl2', {alpha:false, antialias:true});
    if (!gl) gl = canvas.getContext('webgl', {alpha:false, antialias:true});

    function resizeCanvas() {
      const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
      const w = Math.floor(innerWidth * dpr), h = Math.floor(innerHeight * dpr);
      if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    addEventListener('resize', resizeCanvas);
    addEventListener('orientationchange', () => {
      // Kick screen-orientation compensation immediately on rotation
      setTimeout(resizeCanvas, 50);
    });
    resizeCanvas();

    // Shaders
    const vsSrc = `
      attribute vec3 aPosition;
      attribute vec2 aUV;
      uniform mat4 uProj;
      uniform mat4 uView;
      uniform mat4 uModel;
      varying vec2 vUV;
      void main() {
        // Flip X so we view the inside of sphere
        vec4 pos = uModel * vec4(aPosition * vec3(-1.0, 1.0, 1.0), 1.0);
        gl_Position = uProj * uView * pos;
        vUV = vec2(1.0 - aUV.x, aUV.y);
      }
    `;
    const fsSrc = `
      precision mediump float;
      varying vec2 vUV;
      uniform sampler2D uTex;
      void main() {
        gl_FragColor = texture2D(uTex, vUV);
      }
    `;
    function compileShader(type, src) {
      const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null;
      }
      return s;
    }
    function createProgram(vs, fs) {
      const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(p)); return null; }
      return p;
    }
    const prog = createProgram(compileShader(gl.VERTEX_SHADER, vsSrc), compileShader(gl.FRAGMENT_SHADER, fsSrc));
    gl.useProgram(prog);
    const loc = {
      aPosition: gl.getAttribLocation(prog, 'aPosition'),
      aUV: gl.getAttribLocation(prog, 'aUV'),
      uProj: gl.getUniformLocation(prog, 'uProj'),
      uView: gl.getUniformLocation(prog, 'uView'),
      uModel: gl.getUniformLocation(prog, 'uModel'),
      uTex: gl.getUniformLocation(prog, 'uTex'),
    };

    // Sphere geometry
    function createSphere(segU=64, segV=64) {
      const verts=[], uvs=[], idx=[];
      for (let y=0; y<=segV; y++) {
        const v = y/segV; const phi = v*Math.PI;
        for (let x=0; x<=segU; x++) {
          const u = x/segU; const theta = u*Math.PI*2.0;
          const sx=Math.sin(phi)*Math.cos(theta), sy=Math.cos(phi), sz=Math.sin(phi)*Math.sin(theta);
          verts.push(sx, sy, sz); uvs.push(u, v);
        }
      }
      for (let y=0; y<segV; y++) {
        for (let x=0; x<segU; x++) {
          const i=y*(segU+1)+x; const a=i, b=i+segU+1, c=i+1, d=i+segU+2; idx.push(a,b,c, c,b,d);
        }
      }
      // Use Uint16 for wide mobile compatibility
      return {verts:new Float32Array(verts), uvs:new Float32Array(uvs), idx:new Uint16Array(idx)};
    }
    const sphere = createSphere(64,64);

    const vboPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
    gl.bufferData(gl.ARRAY_BUFFER, sphere.verts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(loc.aPosition); gl.vertexAttribPointer(loc.aPosition, 3, gl.FLOAT, false, 0, 0);

    const vboUV = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vboUV);
    gl.bufferData(gl.ARRAY_BUFFER, sphere.uvs, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(loc.aUV); gl.vertexAttribPointer(loc.aUV, 2, gl.FLOAT, false, 0, 0);

    const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.idx, gl.STATIC_DRAW);

    // Model matrix (big sphere)
    function mat4Identity(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
    function mat4Scale(sx,sy,sz){ const m=mat4Identity(); m[0]=sx; m[5]=sy; m[10]=sz; return m; }
    const modelMatrix = mat4Scale(5000,5000,5000);

    // Texture from <video>
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.uniform1i(loc.uTex, 0);

    function updateVideoTexture() {
      if (video.readyState >= 2 && !video.paused) {
        try {
          gl.bindTexture(gl.TEXTURE_2D, tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        } catch (e) {
          try { gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, video); } catch(e2){}
        }
      }
    }

    // Basic math
    function perspective(out, fovy, aspect, near, far){
      const f=1.0/Math.tan(fovy/2), nf=1/(near-far);
      out[0]=f/aspect; out[1]=0; out[2]=0; out[3]=0;
      out[4]=0; out[5]=f; out[6]=0; out[7]=0;
      out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
      out[12]=0; out[13]=0; out[14]=2*far*near*nf; out[15]=0; return out;
    }

    // ======== Render loop (mono + Cardboard SBS) ========
    let cardboard = false;
    const proj = new Float32Array(16);
    const view = new Float32Array(16);
    const viewRot = new Float32Array(16);

    // Smoothing factor (0..1): higher = more responsive, lower = smoother
    const SMOOTH = 0.22;

    function render() {
      resizeCanvas();
      gl.clearColor(0,0,0,1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.disable(gl.CULL_FACE); gl.disable(gl.DEPTH_TEST);
      updateVideoTexture();
      gl.useProgram(prog);
      gl.uniform1i(loc.uTex, 0);
      gl.uniformMatrix4fv(loc.uModel, false, modelMatrix);

      // Smooth orientation
      smoothedHeadQ = quatSlerp(smoothedHeadQ, targetHeadQ, SMOOTH);

      // Camera view = inverse of head rotation
      const rot = quatToMat4(smoothedHeadQ);
      mat4Invert(viewRot, rot);

      if (cardboard) {
        const w = canvas.width, h = canvas.height, halfW = (w/2)|0;
        // ~90° FOV is comfortable in cardboard
        perspective(proj, Math.PI/2.1, halfW/h, 0.1, 10000.0);

        // Left eye
        gl.viewport(0, 0, halfW, h);
        gl.uniformMatrix4fv(loc.uProj, false, proj);
        gl.uniformMatrix4fv(loc.uView, false, viewRot);
        gl.drawElements(gl.TRIANGLES, sphere.idx.length, gl.UNSIGNED_SHORT, 0);

        // Right eye (same mono content — monoscopic video)
        gl.viewport(halfW, 0, halfW, h);
        gl.uniformMatrix4fv(loc.uProj, false, proj);
        gl.uniformMatrix4fv(loc.uView, false, viewRot);
        gl.drawElements(gl.TRIANGLES, sphere.idx.length, gl.UNSIGNED_SHORT, 0);
      } else {
        perspective(proj, Math.PI/2.2, canvas.width/canvas.height, 0.1, 10000.0);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniformMatrix4fv(loc.uProj, false, proj);
        gl.uniformMatrix4fv(loc.uView, false, viewRot);
        gl.drawElements(gl.TRIANGLES, sphere.idx.length, gl.UNSIGNED_SHORT, 0);
      }
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    // ======== Cardboard flow ========
    async function enterCardboard() {
      const permissionGranted = await requestOrientationPermission();
      if (!permissionGranted) {
        showToast('Motion/Orientation permission denied');
        return;
      }

      try {
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
      } catch (e) { console.warn("Fullscreen request failed", e); }

      await ensureVideoPlays();
      await lockLandscape();
      await requestWakeLock();

      brand.classList.add('hidden');
      await new Promise((resolve) => {
        const done = () => { ui.classList.add('hidden'); ui.removeEventListener('transitionend', done); resolve(); };
        ui.classList.add('fade');
        if (getComputedStyle(ui).transitionDuration !== '0s') {
          ui.addEventListener('transitionend', done, {once:true});
        } else { done(); }
      });

      // Initialize recenter so "current forward" is forward on entry
      recenterNow();

      cardboard = true;
      showToast('Cardboard mode');
    }

    cardboardBtn.addEventListener('click', () => {
      enterCardboard().catch(err => {
        console.error(err);
        cardboard = false;
        ui.classList.remove('hidden');
        brand.classList.remove('hidden');
        showToast('Could not enter Cardboard mode');
      });
    });

    // Start preview & UI fade
    requestAnimationFrame(() => { scheduleUIHide(); });
  })();
  </script>
</body>
</html>
